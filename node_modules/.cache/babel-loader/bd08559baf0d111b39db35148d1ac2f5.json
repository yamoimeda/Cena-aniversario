{"ast":null,"code":"// add, remove cell\n(function (window, factory) {\n  // universal module definition\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'fizzy-ui-utils/utils'], function (Flickity, utils) {\n      return factory(window, Flickity, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./flickity'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    factory(window, window.Flickity, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, utils) {\n  'use strict'; // append cells to a document fragment\n\n  function getCellsFragment(cells) {\n    var fragment = document.createDocumentFragment();\n    cells.forEach(function (cell) {\n      fragment.appendChild(cell.element);\n    });\n    return fragment;\n  } // -------------------------- add/remove cell prototype -------------------------- //\n\n\n  var proto = Flickity.prototype;\n  /**\n   * Insert, prepend, or append cells\n   * @param {[Element, Array, NodeList]} elems - Elements to insert\n   * @param {Integer} index - Zero-based number to insert\n   */\n\n  proto.insert = function (elems, index) {\n    var cells = this._makeCells(elems);\n\n    if (!cells || !cells.length) {\n      return;\n    }\n\n    var len = this.cells.length; // default to append\n\n    index = index === undefined ? len : index; // add cells with document fragment\n\n    var fragment = getCellsFragment(cells); // append to slider\n\n    var isAppend = index == len;\n\n    if (isAppend) {\n      this.slider.appendChild(fragment);\n    } else {\n      var insertCellElement = this.cells[index].element;\n      this.slider.insertBefore(fragment, insertCellElement);\n    } // add to this.cells\n\n\n    if (index === 0) {\n      // prepend, add to start\n      this.cells = cells.concat(this.cells);\n    } else if (isAppend) {\n      // append, add to end\n      this.cells = this.cells.concat(cells);\n    } else {\n      // insert in this.cells\n      var endCells = this.cells.splice(index, len - index);\n      this.cells = this.cells.concat(cells).concat(endCells);\n    }\n\n    this._sizeCells(cells);\n\n    this.cellChange(index, true);\n  };\n\n  proto.append = function (elems) {\n    this.insert(elems, this.cells.length);\n  };\n\n  proto.prepend = function (elems) {\n    this.insert(elems, 0);\n  };\n  /**\n   * Remove cells\n   * @param {[Element, Array, NodeList]} elems - ELements to remove\n   */\n\n\n  proto.remove = function (elems) {\n    var cells = this.getCells(elems);\n\n    if (!cells || !cells.length) {\n      return;\n    }\n\n    var minCellIndex = this.cells.length - 1; // remove cells from collection & DOM\n\n    cells.forEach(function (cell) {\n      cell.remove();\n      var index = this.cells.indexOf(cell);\n      minCellIndex = Math.min(index, minCellIndex);\n      utils.removeFrom(this.cells, cell);\n    }, this);\n    this.cellChange(minCellIndex, true);\n  };\n  /**\n   * logic to be run after a cell's size changes\n   * @param {Element} elem - cell's element\n   */\n\n\n  proto.cellSizeChange = function (elem) {\n    var cell = this.getCell(elem);\n\n    if (!cell) {\n      return;\n    }\n\n    cell.getSize();\n    var index = this.cells.indexOf(cell);\n    this.cellChange(index);\n  };\n  /**\n   * logic any time a cell is changed: added, removed, or size changed\n   * @param {Integer} changedCellIndex - index of the changed cell, optional\n   * @param {Boolean} isPositioningSlider - Positions slider after selection\n   */\n\n\n  proto.cellChange = function (changedCellIndex, isPositioningSlider) {\n    var prevSelectedElem = this.selectedElement;\n\n    this._positionCells(changedCellIndex);\n\n    this._getWrapShiftCells();\n\n    this.setGallerySize(); // update selectedIndex\n    // try to maintain position & select previous selected element\n\n    var cell = this.getCell(prevSelectedElem);\n\n    if (cell) {\n      this.selectedIndex = this.getCellSlideIndex(cell);\n    }\n\n    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);\n    this.emitEvent('cellChange', [changedCellIndex]); // position slider\n\n    this.select(this.selectedIndex); // do not position slider after lazy load\n\n    if (isPositioningSlider) {\n      this.positionSliderAtSelected();\n    }\n  }; // -----  ----- //\n\n\n  return Flickity;\n});","map":{"version":3,"sources":["C:/Users/LabJH/Documents/yamir/cit/minaposento/node_modules/flickity/js/add-remove-cell.js"],"names":["window","factory","define","amd","Flickity","utils","module","exports","require","fizzyUIUtils","getCellsFragment","cells","fragment","document","createDocumentFragment","forEach","cell","appendChild","element","proto","prototype","insert","elems","index","_makeCells","length","len","undefined","isAppend","slider","insertCellElement","insertBefore","concat","endCells","splice","_sizeCells","cellChange","append","prepend","remove","getCells","minCellIndex","indexOf","Math","min","removeFrom","cellSizeChange","elem","getCell","getSize","changedCellIndex","isPositioningSlider","prevSelectedElem","selectedElement","_positionCells","_getWrapShiftCells","setGallerySize","selectedIndex","getCellSlideIndex","slides","emitEvent","select","positionSliderAtSelected"],"mappings":"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","sourcesContent":["// add, remove cell\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'fizzy-ui-utils/utils',\n    ], function( Flickity, utils ) {\n      return factory( window, Flickity, utils );\n    } );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./flickity'),\n        require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    factory(\n        window,\n        window.Flickity,\n        window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, utils ) {\n\n'use strict';\n\n// append cells to a document fragment\nfunction getCellsFragment( cells ) {\n  var fragment = document.createDocumentFragment();\n  cells.forEach( function( cell ) {\n    fragment.appendChild( cell.element );\n  } );\n  return fragment;\n}\n\n// -------------------------- add/remove cell prototype -------------------------- //\n\nvar proto = Flickity.prototype;\n\n/**\n * Insert, prepend, or append cells\n * @param {[Element, Array, NodeList]} elems - Elements to insert\n * @param {Integer} index - Zero-based number to insert\n */\nproto.insert = function( elems, index ) {\n  var cells = this._makeCells( elems );\n  if ( !cells || !cells.length ) {\n    return;\n  }\n  var len = this.cells.length;\n  // default to append\n  index = index === undefined ? len : index;\n  // add cells with document fragment\n  var fragment = getCellsFragment( cells );\n  // append to slider\n  var isAppend = index == len;\n  if ( isAppend ) {\n    this.slider.appendChild( fragment );\n  } else {\n    var insertCellElement = this.cells[ index ].element;\n    this.slider.insertBefore( fragment, insertCellElement );\n  }\n  // add to this.cells\n  if ( index === 0 ) {\n    // prepend, add to start\n    this.cells = cells.concat( this.cells );\n  } else if ( isAppend ) {\n    // append, add to end\n    this.cells = this.cells.concat( cells );\n  } else {\n    // insert in this.cells\n    var endCells = this.cells.splice( index, len - index );\n    this.cells = this.cells.concat( cells ).concat( endCells );\n  }\n\n  this._sizeCells( cells );\n  this.cellChange( index, true );\n};\n\nproto.append = function( elems ) {\n  this.insert( elems, this.cells.length );\n};\n\nproto.prepend = function( elems ) {\n  this.insert( elems, 0 );\n};\n\n/**\n * Remove cells\n * @param {[Element, Array, NodeList]} elems - ELements to remove\n */\nproto.remove = function( elems ) {\n  var cells = this.getCells( elems );\n  if ( !cells || !cells.length ) {\n    return;\n  }\n\n  var minCellIndex = this.cells.length - 1;\n  // remove cells from collection & DOM\n  cells.forEach( function( cell ) {\n    cell.remove();\n    var index = this.cells.indexOf( cell );\n    minCellIndex = Math.min( index, minCellIndex );\n    utils.removeFrom( this.cells, cell );\n  }, this );\n\n  this.cellChange( minCellIndex, true );\n};\n\n/**\n * logic to be run after a cell's size changes\n * @param {Element} elem - cell's element\n */\nproto.cellSizeChange = function( elem ) {\n  var cell = this.getCell( elem );\n  if ( !cell ) {\n    return;\n  }\n  cell.getSize();\n\n  var index = this.cells.indexOf( cell );\n  this.cellChange( index );\n};\n\n/**\n * logic any time a cell is changed: added, removed, or size changed\n * @param {Integer} changedCellIndex - index of the changed cell, optional\n * @param {Boolean} isPositioningSlider - Positions slider after selection\n */\nproto.cellChange = function( changedCellIndex, isPositioningSlider ) {\n  var prevSelectedElem = this.selectedElement;\n  this._positionCells( changedCellIndex );\n  this._getWrapShiftCells();\n  this.setGallerySize();\n  // update selectedIndex\n  // try to maintain position & select previous selected element\n  var cell = this.getCell( prevSelectedElem );\n  if ( cell ) {\n    this.selectedIndex = this.getCellSlideIndex( cell );\n  }\n  this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );\n\n  this.emitEvent( 'cellChange', [ changedCellIndex ] );\n  // position slider\n  this.select( this.selectedIndex );\n  // do not position slider after lazy load\n  if ( isPositioningSlider ) {\n    this.positionSliderAtSelected();\n  }\n};\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"]},"metadata":{},"sourceType":"script"}