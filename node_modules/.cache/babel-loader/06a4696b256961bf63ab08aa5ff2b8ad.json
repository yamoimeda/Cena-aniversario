{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'unidragger/unidragger', 'fizzy-ui-utils/utils'], function (Flickity, Unidragger, utils) {\n      return factory(window, Flickity, Unidragger, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./flickity'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, Unidragger, utils) {\n  'use strict'; // ----- defaults ----- //\n\n  utils.extend(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  }); // ----- create ----- //\n\n  Flickity.createMethods.push('_createDrag'); // -------------------------- drag prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n  utils.extend(proto, Unidragger.prototype);\n  proto._touchActionValue = 'pan-y'; // --------------------------  -------------------------- //\n\n  var isTouch = ('createTouch' in document);\n  var isTouchmoveScrollCanceled = false;\n\n  proto._createDrag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable); // TODO updateDraggable on resize? if groupCells & slides change\n    // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n    // #457, RubaXa/Sortable#973\n\n    if (isTouch && !isTouchmoveScrollCanceled) {\n      window.addEventListener('touchmove', function () {});\n      isTouchmoveScrollCanceled = true;\n    }\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable == '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n\n    if (this.isDraggable) {\n      this.element.classList.add('is-draggable');\n    } else {\n      this.element.classList.remove('is-draggable');\n    }\n  }; // backwards compatibility\n\n\n  proto.bindDrag = function () {\n    this.options.draggable = true;\n    this.updateDraggable();\n  };\n\n  proto.unbindDrag = function () {\n    this.options.draggable = false;\n    this.updateDraggable();\n  };\n\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  }; // -------------------------- pointer events -------------------------- //\n\n\n  proto.pointerDown = function (event, pointer) {\n    if (!this.isDraggable) {\n      this._pointerDownDefault(event, pointer);\n\n      return;\n    }\n\n    var isOkay = this.okayPointerDown(event);\n\n    if (!isOkay) {\n      return;\n    }\n\n    this._pointerDownPreventDefault(event);\n\n    this.pointerDownFocus(event); // blur\n\n    if (document.activeElement != this.element) {\n      // do not blur if already focused\n      this.pointerDownBlur();\n    } // stop if it was moving\n\n\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down'); // track scrolling\n\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n\n    this._pointerDownDefault(event, pointer);\n  }; // default pointerDown logic, used for staticClick\n\n\n  proto._pointerDownDefault = function (event, pointer) {\n    // track start event position\n    // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    }; // bind move and end events\n\n    this._bindPostStartEvents(event);\n\n    this.dispatchEvent('pointerDown', event, [pointer]);\n  };\n\n  var focusNodes = {\n    INPUT: true,\n    TEXTAREA: true,\n    SELECT: true\n  };\n\n  proto.pointerDownFocus = function (event) {\n    var isFocusNode = focusNodes[event.target.nodeName];\n\n    if (!isFocusNode) {\n      this.focus();\n    }\n  };\n\n  proto._pointerDownPreventDefault = function (event) {\n    var isTouchStart = event.type == 'touchstart';\n    var isTouchPointer = event.pointerType == 'touch';\n    var isFocusNode = focusNodes[event.target.nodeName];\n\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) {\n      event.preventDefault();\n    }\n  }; // ----- move ----- //\n\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  }; // ----- up ----- //\n\n\n  proto.pointerUp = function (event, pointer) {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n    this.dispatchEvent('pointerUp', event, [pointer]);\n\n    this._dragPointerUp(event, pointer);\n  };\n\n  proto.pointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  }; // -------------------------- dragging -------------------------- //\n\n\n  proto.dragStart = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n    this.dispatchEvent('dragStart', event, [pointer]);\n  };\n\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n\n    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);\n\n    this._dragMove(event, pointer, moveVector);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) {\n      return;\n    }\n\n    event.preventDefault();\n    this.previousDragX = this.dragX; // reverse if right-to-left\n\n    var direction = this.options.rightToLeft ? -1 : 1;\n\n    if (this.options.wrapAround) {\n      // wrap around move. #589\n      moveVector.x %= this.slideableWidth;\n    }\n\n    var dragX = this.dragStartPosition + moveVector.x * direction;\n\n    if (!this.options.wrapAround && this.slides.length) {\n      // slow drag\n      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n    this.dispatchEvent('dragMove', event, [pointer, moveVector]);\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n\n    if (this.options.freeScroll) {\n      this.isFreeScrolling = true;\n    } // set selectedIndex based on where flick will end up\n\n\n    var index = this.dragEndRestingSelect();\n\n    if (this.options.freeScroll && !this.options.wrapAround) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      var restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!this.options.freeScroll && index == this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n\n    delete this.previousDragX; // apply selection\n    // TODO refactor this, selecting here feels weird\n    // HACK, set flag so dragging stays in correct direction\n\n    this.isDragSelect = this.options.wrapAround;\n    this.select(index);\n    delete this.isDragSelect;\n    this.dispatchEvent('dragEnd', event, [pointer]);\n  };\n\n  proto.dragEndRestingSelect = function () {\n    var restingX = this.getRestingPosition(); // how far away from selected slide\n\n    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex)); // get closet resting going up and going down\n\n    var positiveResting = this._getClosestResting(restingX, distance, 1);\n\n    var negativeResting = this._getClosestResting(restingX, distance, -1); // use closer resting for wrap-around\n\n\n    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n    return index;\n  };\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n\n\n  proto._getClosestResting = function (restingX, distance, increment) {\n    var index = this.selectedIndex;\n    var minDistance = Infinity;\n    var condition = this.options.contain && !this.options.wrapAround ? // if contain, keep going if distance is equal to minDistance\n    function (dist, minDist) {\n      return dist <= minDist;\n    } : function (dist, minDist) {\n      return dist < minDist;\n    };\n\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n\n      if (distance === null) {\n        break;\n      }\n\n      distance = Math.abs(distance);\n    }\n\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n\n\n  proto.getSlideDistance = function (x, index) {\n    var len = this.slides.length; // wrap around if at least 2 slides\n\n    var isWrapAround = this.options.wrapAround && len > 1;\n    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    var slide = this.slides[slideIndex];\n\n    if (!slide) {\n      return null;\n    } // add distance for wrap-around slides\n\n\n    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime || // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n\n    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    var delta = this.previousDragX - this.dragX;\n\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n\n    return 0;\n  }; // ----- staticClick ----- //\n\n\n  proto.staticClick = function (event, pointer) {\n    // get clickedCell, if cell was clicked\n    var clickedCell = this.getParentCell(event.target);\n    var cellElem = clickedCell && clickedCell.element;\n    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);\n    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);\n  }; // ----- scroll ----- //\n\n\n  proto.onscroll = function () {\n    var scroll = getScrollPosition();\n    var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    var scrollMoveY = this.pointerDownScroll.y - scroll.y; // cancel click/tap if scroll is too much\n\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this._pointerDone();\n    }\n  }; // ----- utils ----- //\n\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  } // -----  ----- //\n\n\n  return Flickity;\n});","map":{"version":3,"sources":["C:/Users/LabJH/Documents/yamir/cit/minaposento/node_modules/flickity/js/drag.js"],"names":["window","factory","define","amd","Flickity","Unidragger","utils","module","exports","require","fizzyUIUtils","extend","defaults","draggable","dragThreshold","createMethods","push","proto","prototype","_touchActionValue","isTouch","document","isTouchmoveScrollCanceled","_createDrag","on","onActivateDrag","_uiChangeDrag","onDeactivateDrag","updateDraggable","addEventListener","handles","viewport","bindHandles","unbindHandles","element","classList","remove","options","isDraggable","slides","length","add","bindDrag","unbindDrag","isFreeScrolling","pointerDown","event","pointer","_pointerDownDefault","isOkay","okayPointerDown","_pointerDownPreventDefault","pointerDownFocus","activeElement","pointerDownBlur","dragX","x","pointerDownScroll","getScrollPosition","pointerDownPointer","pageX","pageY","_bindPostStartEvents","dispatchEvent","focusNodes","INPUT","TEXTAREA","SELECT","isFocusNode","target","nodeName","focus","isTouchStart","type","isTouchPointer","pointerType","preventDefault","hasDragStarted","moveVector","Math","abs","pointerUp","isTouchScrolling","_dragPointerUp","pointerDone","removeEventListener","dragStart","dragStartPosition","startAnimation","pointerMove","_dragPointerMove","_dragMove","dragMove","previousDragX","direction","rightToLeft","wrapAround","slideableWidth","originBound","max","endBound","min","getLastSlide","dragMoveTime","Date","dragEnd","freeScroll","index","dragEndRestingSelect","restingX","getRestingPosition","selectedIndex","dragEndBoostSelect","isDragSelect","select","distance","getSlideDistance","positiveResting","_getClosestResting","negativeResting","increment","minDistance","Infinity","condition","contain","dist","minDist","len","isWrapAround","slideIndex","modulo","slide","wrap","floor","undefined","delta","staticClick","clickedCell","getParentCell","cellElem","cellIndex","cells","indexOf","onscroll","scroll","scrollMoveX","scrollMoveY","y","_pointerDone","pageXOffset","pageYOffset"],"mappings":"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","sourcesContent":["// drag\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'unidragger/unidragger',\n      'fizzy-ui-utils/utils',\n    ], function( Flickity, Unidragger, utils ) {\n      return factory( window, Flickity, Unidragger, utils );\n    } );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./flickity'),\n        require('unidragger'),\n        require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n        window,\n        window.Flickity,\n        window.Unidragger,\n        window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, Unidragger, utils ) {\n\n'use strict';\n\n// ----- defaults ----- //\n\nutils.extend( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n} );\n\n// ----- create ----- //\n\nFlickity.createMethods.push('_createDrag');\n\n// -------------------------- drag prototype -------------------------- //\n\nvar proto = Flickity.prototype;\nutils.extend( proto, Unidragger.prototype );\nproto._touchActionValue = 'pan-y';\n\n// --------------------------  -------------------------- //\n\nvar isTouch = 'createTouch' in document;\nvar isTouchmoveScrollCanceled = false;\n\nproto._createDrag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'deactivate', this.onDeactivateDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  // TODO updateDraggable on resize? if groupCells & slides change\n  // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n  // #457, RubaXa/Sortable#973\n  if ( isTouch && !isTouchmoveScrollCanceled ) {\n    window.addEventListener( 'touchmove', function() {} );\n    isTouchmoveScrollCanceled = true;\n  }\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable == '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  if ( this.isDraggable ) {\n    this.element.classList.add('is-draggable');\n  } else {\n    this.element.classList.remove('is-draggable');\n  }\n};\n\n// backwards compatibility\nproto.bindDrag = function() {\n  this.options.draggable = true;\n  this.updateDraggable();\n};\n\nproto.unbindDrag = function() {\n  this.options.draggable = false;\n  this.updateDraggable();\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.pointerDown = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    this._pointerDownDefault( event, pointer );\n    return;\n  }\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n\n  this._pointerDownPreventDefault( event );\n  this.pointerDownFocus( event );\n  // blur\n  if ( document.activeElement != this.element ) {\n    // do not blur if already focused\n    this.pointerDownBlur();\n  }\n\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n\n  this._pointerDownDefault( event, pointer );\n};\n\n// default pointerDown logic, used for staticClick\nproto._pointerDownDefault = function( event, pointer ) {\n  // track start event position\n  // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\n  this.pointerDownPointer = {\n    pageX: pointer.pageX,\n    pageY: pointer.pageY,\n  };\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.dispatchEvent( 'pointerDown', event, [ pointer ] );\n};\n\nvar focusNodes = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n};\n\nproto.pointerDownFocus = function( event ) {\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isFocusNode ) {\n    this.focus();\n  }\n};\n\nproto._pointerDownPreventDefault = function( event ) {\n  var isTouchStart = event.type == 'touchstart';\n  var isTouchPointer = event.pointerType == 'touch';\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) {\n    event.preventDefault();\n  }\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.pointerUp = function( event, pointer ) {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n  this.dispatchEvent( 'pointerUp', event, [ pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto.pointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n};\n\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  var direction = this.options.rightToLeft ? -1 : 1;\n  if ( this.options.wrapAround ) {\n    // wrap around move. #589\n    moveVector.x %= this.slideableWidth;\n  }\n  var dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.options.wrapAround && this.slides.length ) {\n    // slow drag\n    var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n\n  this.dragMoveTime = new Date();\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  if ( this.options.freeScroll ) {\n    this.isFreeScrolling = true;\n  }\n  // set selectedIndex based on where flick will end up\n  var index = this.dragEndRestingSelect();\n\n  if ( this.options.freeScroll && !this.options.wrapAround ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    var restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !this.options.freeScroll && index == this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // TODO refactor this, selecting here feels weird\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.options.wrapAround;\n  this.select( index );\n  delete this.isDragSelect;\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\nproto.dragEndRestingSelect = function() {\n  var restingX = this.getRestingPosition();\n  // how far away from selected slide\n  var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  var positiveResting = this._getClosestResting( restingX, distance, 1 );\n  var negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  var index = positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n  return index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  var index = this.selectedIndex;\n  var minDistance = Infinity;\n  var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function( dist, minDist ) {\n      return dist <= minDist;\n    } : function( dist, minDist ) {\n      return dist < minDist;\n    };\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) {\n      break;\n    }\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment,\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x - horizontal position\n * @param {Integer} index - slide index\n * @returns {Number} - slide distance\n */\nproto.getSlideDistance = function( x, index ) {\n  var len = this.slides.length;\n  // wrap around if at least 2 slides\n  var isWrapAround = this.options.wrapAround && len > 1;\n  var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  var slide = this.slides[ slideIndex ];\n  if ( !slide ) {\n    return null;\n  }\n  // add distance for wrap-around slides\n  var wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  var delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  // get clickedCell, if cell was clicked\n  var clickedCell = this.getParentCell( event.target );\n  var cellElem = clickedCell && clickedCell.element;\n  var cellIndex = clickedCell && this.cells.indexOf( clickedCell );\n  this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  var scroll = getScrollPosition();\n  var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this._pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset,\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"]},"metadata":{},"sourceType":"script"}